TCP(Transportation Control Protocol)协议与IP协议是一同产生的。事实上，两者最初是一个协议，后来才被分拆成网络层的IP和传输层的TCP。我们已经在傀儡 UDP协议（戳我）中介绍过，**UDP协议**是IP协议在传输层的“傀儡”，用来**实现`数据包`形式的通信**。而**TCP协议**则**实现了`“流”`形式的通信**。

这一篇主要介绍TCP协议的下面几个方面：

>1、“流”通信的意义与实现方式
>
>2、如何实现可靠传输
>
>3、使用滑窗提高效率

## "流"通信

**`TCP协议`是`传输层协议`，实现的是`端口到端口(port)`的通信**。我们知道，计算机数据的本质是有序的0/1序列(如果以byte为单位，就叫做文本流)，计算机的功能就是储存和处理文本流。CPU + memory + 存储设备实现了文本流在同一台计算机内部的加工处理。通过一些IO，比如屏幕和键盘，文本流实现了人机交互。而进一步，如果网络通信可在不同计算机之间进行文本流的交互，那么我们就和整个计算机系统的数据处理方式实现了对接。

IP协议(参考前面文章协议森林03, 05)和UDP协议采用的是数据包的方式传送，后发出的数据包可能早到，我们并不能保证数据到达的次序。**TCP协议确保了数据到达的顺序与文本流顺序相符**。当计算机从TCP协议的接口读取数据时，这些数据已经是排列好顺序的“流”了。

比如我们有一个大文件要从本地主机发送到远程主机，如果是按照TCP“流”接收到的话，我们可以一边接收，一边将文本流存入文件系统。这样，等到“流”接收完了，硬盘写入操作也已经完成。如果采取UDP的传输方式，我们需要等到所有的数据到达后，进行排序，才能组装成大的文件。这种情况下，我们不得不使用大量的计算机资源来存储已经到达的数据，直到所有数据都达到了，才能开始处理。

**“流”的要点是次序(order)**，然而实现这一点并不简单。TCP协议是基于IP协议的，所以最终数据传送还是以IP数据包为单位进行的。如果一个文本流很长的话，我们不可能将整个文本流放入到一个IP数据包中，那样有可能会超过MTU。

所以，**TCP协议封装到IP包的不是整个文本流，而是TCP协议所规定的`片段(segment)`**。与之前的一个IP或者UDP数据包类似，一个TCP片段同样分为头部(header)和数据(payload)两部分 (“片段”这个名字更多是起提醒作用：嘿，这里并不是完整的文本流)。整个文本流按照次序被分成小段，而每一段被放入TCP片段的数据部分。一个TCP片段封装成的IP包不超过整个IP接力路径上的最小MTU，从而避免令人痛苦的碎片化(fragmentation)。

(**给`文本流分段`是在`发送主机`完成的，而`碎片化`是在网络中的`路由器`完成的**。路由器要处理许多路的通信，所以相当繁忙。文本流提前在发送主机分好段，可以避免在路由器上执行碎片化，可大大减小网络负担)

![](../images/tcp_1.webp)

**`TCP片段`的`头部(header)`会存有该片段的`序号(sequence number)`**。这样，接收的计算机就可以知道接收到的片段在原文本流中的顺序了，也可以知道自己下一步需要接收哪个片段以形成流。比如已经接收到了片段1，片段2，片段3，那么接收主机就开始期待片段4。如果接收到不符合顺序的数据包(比如片段8)，接收方的TCP模块可以拒绝接收，从而保证呈现给接收主机的信息是符合次序的“流”。

